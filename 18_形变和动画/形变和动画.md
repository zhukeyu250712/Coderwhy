# 形变和动画

# 一、transform

## 1、CSS属性 - transform

* CSS transform属性允许对某一个元素进行某些形变, 包括旋转，缩放，倾斜或平移等。

* transform是形变的意思，transformer就是变形金刚；

* 注意事项，并非所有的盒子都可以进行transform的转换（通常行内级元素不能进行形变）
* ![image-20230902205158792](../../../Coderwhy/pic/image-20230902205158792.png)

![image-20230902201651474](../../../Coderwhy/pic/image-20230902201651474.png)

* 所以，transform对于行内级非替换元素是无效的；
	* 比如对span、a元素等；

## 2、transform的用法

* transform属性的语法如下：

![image-20230902201749384](../../../Coderwhy/pic/image-20230902201749384.png)

* 常见的函数transform function有：
	* 平移：translate(x, y)
	* 缩放：scale(x, y)
	* 旋转：rotate(deg)
	* 倾斜：skew(deg, deg)

* 通过上面的几个函数，我们可以改变某个元素的形变

![image-20230902201839906](../../../Coderwhy/pic/image-20230902201839906.png)

## 3、位移 - translate

* 平移：translate(x, y)
	* 这个CSS 函数用于移动元素在平面上的位置。
	* translate本身可以表示翻译的意思，在物理上也可以表示平移；

* 值个数
	* 一个值时，设置x轴上的位移
	* 二个值时，设置x轴和y轴上的位移

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .container {
      display: inline-block;
      border: 5px solid #f00;
    }

    .container .box {
      width: 200px;
      height: 200px;
      background-color: orange;
      /* x和y 轴平移100px */
      transform: translate(100px, 100px);
    }
  </style>

</head>
<body>
  
  <div class="container">
    <div class="box">

    </div>
  </div>

</body>
</html>
```

![image-20230902205453690](../../../Coderwhy/pic/image-20230902205453690.png)

* 值类型：
	* 数字：100px
	* 百分比：参照元素本身（ refer to the size of bounding box ）

![image-20230902201955814](../../../Coderwhy/pic/image-20230902201955814.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .container {
      display: inline-block;
      border: 5px solid #f00;
    }

    .container .box {
      width: 200px;
      height: 200px;
      background-color: orange;
      /* 百分比：你的百分比是相对于谁？ */
      /* 不同地方的百分比相对参照物是不一样 */

      /* 
      translate的百分比是相对于自身的
      如果设置的 x 位移: 那么参考的是自身的宽度
      如果设置的 y 位移: 那么参考的是自身的高度
      */
      transform: translate(100%, 50%);
    }
  </style>

</head>
<body>
  
  <div class="container">
    <div class="box">

    </div>
  </div>

</body>
</html>
```

![image-20230902205526231](../../../Coderwhy/pic/image-20230902205526231.png)



# 二、垂直居中总结

## 1、translate的补充一

* translate是translateX和translateY函数的简写。
	* translate3d后续了解；

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .container {
      display: inline-block;
      border: 5px solid #f00;
    }

    .container .box {
      width: 200px;
      height: 200px;
      background-color: orange;
      /* 百分比：你的百分比是相对于谁？ */
      /* 不同地方的百分比相对参照物是不一样 */

      /* 
      translate的百分比是相对于自身的
      如果设置的 x 位移: 那么参考的是自身的宽度
      如果设置的 y 位移: 那么参考的是自身的高度
      */
      /* transform: translate(100%, 50%); */

      /* 只能写X或者Y的一个 */
      transform: translateX(100%);
      /* transform: translateY(); */
    }
  </style>

</head>
<body>
  
  <div class="container">
    <div class="box">

    </div>
  </div>

</body>
</html>
```

![image-20230902205919913](../../../Coderwhy/pic/image-20230902205919913.png)

## 2、水平垂直居中

### (1)水平居中

水平居中：

* 行内及元素
	* 设置父元素的 text-align: center
* 块级元素
	* 设置当前块级元素(必须要有宽度) margin: 0 auto
* 绝对定位
	* 元素有宽度的情况下，left:0 / right:0 / margin: 0 auto
* flex
	* justify-content:center

### (2) 垂直居中：绝对定位

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .container {
      position: relative;
      height: 300px;
      background-color: orange;
    }

    .container .box1 {
      position: absolute;
      width: 100px;
      height: 100px;
      /* height: auto; */
      top: 0;
      bottom: 0;
      margin: auto 0;
      background-color: #f00;
    }
  </style>
</head>
<body>
  <!-- 
    水平居中：
    1、行内及元素
      * 设置父元素的text-align: center
    2、块级元素
      * 设置当前块级元素(必须要有宽度) margin: 0 auto
    3、绝对定位
      * 元素有宽度的情况下，left:0 / right:0 / margin: 0 auto
    4、flex
      * justify-content:center
   -->

   <!-- 
    垂直居中：
    1、绝对定位
      * 元素有高度的情况下,top:0 / bottom: 0 / margin: auto 0
      弊端：
        1> 必须使用定位(脱离标准流)
        2> 必须给元素设置高度
    -->

    <!-- 
      1、垂直居中：绝对定位 
    -->
    <div class="container">
      <div class="box1">zky</div>
    </div>

</body>
</html>
```

![image-20230902212726860](../../../Coderwhy/pic/image-20230902212726860.png)

### (3)垂直居中:flex 布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 1、垂直居中：绝对定位  */
    /* .container {
      position: relative;
      height: 300px;
      background-color: orange;
    } */

    /* 2、垂直居中:flex 布局  */
    .container {
      display: flex;
      align-items: center;

      height: 300px;
      background-color: orange;
    }

    .box1 {
      position: absolute;
      width: 100px;
      /* height: 100px; */
      /* height: auto; */
      top: 0;
      bottom: 0;
      margin: auto 0;
      background-color: #f00;
    }

    .box2 {
      background-color: #f00;
    }
  </style>
</head>
<body>
  <!-- 
    水平居中：
    1、行内及元素
      * 设置父元素的text-align: center
    2、块级元素
      * 设置当前块级元素(必须要有宽度) margin: 0 auto
    3、绝对定位
      * 元素有宽度的情况下，left:0 / right:0 / margin: 0 auto
    4、flex
      * justify-content:center
   -->

   <!-- 
    垂直居中：
    1、绝对定位
      * 元素有高度的情况下,top:0 / bottom: 0 / margin: auto 0
      弊端：
        1> 必须使用定位(脱离标准流)
        2> 必须给元素设置高度

    2、垂直居中:flex 布局
      弊端：
        1> 当前flex布局中所有的元素都会被垂直居中(aaa被垂直居中)
        2> 相对来说兼容性差一点点(基本可以忽略)
    -->

    <!-- 1、垂直居中：绝对定位 -->
    <!-- <div class="container">
      <div class="box1">zky</div>
    </div> -->

    <!-- 2、垂直居中:flex 布局 -->
    <div class="container">
      <div class="box2">flex布局的居中</div>
      aaa
    </div>

</body>
</html>
```

![image-20230902213907376](../../../Coderwhy/pic/image-20230902213907376.png)

### (4)垂直居中：top/translate

* translate的百分比可以完成一个元素的水平和垂直居中：

![image-20230902202100831](../../../Coderwhy/pic/image-20230902202100831.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 1、垂直居中：绝对定位  */
    /* .container {
      position: relative;
      height: 300px;
      background-color: orange;
    } */

    /* 2、垂直居中:flex 布局  */
    /* .container {
      display: flex;
      align-items: center;

      height: 300px;
      background-color: orange;
    } */

    /* 3、垂直居中：top/translate */
    .container {
      height: 300px;
      background-color: orange;
    }

    .box1 {
      position: absolute;
      width: 100px;
      /* height: 100px; */
      /* height: auto; */
      top: 0;
      bottom: 0;
      margin: auto 0;
      background-color: #f00;
    }

    .box2 {
      background-color: #f00;
    }

    .box3 {
      display: inline-block;
      height: 100px;
      background-color: #f00;

      /* 方法：
        1、让元素向下位移父元素的 50%
        2、再让元素向上移动自身的 50% */

        /* 1、让元素向下位移父元素的 50% */
        /*这个是不对的:
        margin-top 的百分比是相对于包含快(这里是父元素)的宽度的
        */
      /* margin-top: 50%;   */

      position:relative;
      /* top: 150px; 等价50% */
      top: 50%;

      /* 2、再让元素向上移动自身的 50% */
      /* y轴相对于自身向上移动 50% */
      transform: translate(0, -50%);
    }
  </style>
</head>
<body>
  <!-- 
    水平居中：
    1、行内及元素
      * 设置父元素的text-align: center
    2、块级元素
      * 设置当前块级元素(必须要有宽度) margin: 0 auto
    3、绝对定位
      * 元素有宽度的情况下，left:0 / right:0 / margin: 0 auto
    4、flex
      * justify-content:center
   -->

   <!-- 
    垂直居中：
    1、绝对定位
      * 元素有高度的情况下,top:0 / bottom: 0 / margin: auto 0
      弊端：
        1> 必须使用定位(脱离标准流)
        2> 必须给元素设置高度

    2、垂直居中:flex布局(直接使用flex)
      弊端：
        1> 当前flex布局中所有的元素都会被垂直居中(aaa被垂直居中)
        2> 相对来说兼容性差一点点(基本可以忽略)

    3、垂直居中：top/translate
      方法：
        * 让元素向下位移父元素的 50%
        * 再让元素向上移动自身的 50%
      推荐，不好理解
    -->

    <!-- 1、垂直居中：绝对定位 -->
    <!-- <div class="container">
      <div class="box1">zky</div>
    </div> -->

    <!-- 2、垂直居中:flex 布局 -->
    <!-- <div class="container">
      <div class="box2">flex布局的居中</div>
      aaa
    </div> -->

    <!-- 3、垂直居中：top/translate -->
    <div class="container">
      <div class="box3">zky</div>
      aaaa
    </div>
</body>
</html>
```

![image-20230902215457879](../../../Coderwhy/pic/image-20230902215457879.png)

* translate函数相对于flex布局的兼容性会好一点点
	* 不过目前flex布局已经非常普及，直接使用flex布局即可；



# 三、transform属性

## 1、缩放 - scale

![image-20230902202311349](../../../Coderwhy/pic/image-20230902202311349.png)

* 缩放：scale(x, y)
	* scale() CSS 函数可改变元素的大小。

* 值个数
	* 一个值时，设置x轴上的缩放
	* 二个值时，设置x轴和y轴上的缩放

* 值类型：
	* 数字：
		* 1：保持不变
		* 2：放大一倍
		* 0.5：缩小一半
	* 百分比：百分比不常用
* scale函数时scaleX和scaleY的缩写：
	* scale3d后续再了解；

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      text-align: center;
      padding-top: 200px;
    }

    .container {
      display: inline-block;
      border: 20px solid #f00;
    }

    .box {
      border: 20px solid #0f0;
      width: 200px;
      height: 200px;
      background-color: orange;

      /* 形变 */
      /* transform: scale(0.6, 0.6); */
      transform: scale(60%, 60%);
    }

    .box1 {
      border: 20px solid #0f0;
      width: 200px;
      height: 200px;
      background-color: purple;

      /* 形变 */
      /* 0~1 对元素进行缩小 */
      /* transform: scale(0.6, 0.6); */
      /* transform: scale(1.2, 1.2); */
    }

    /* 悬浮之后缩放 */
    .box1:hover {
      transform: scale(1.1, 1.1);
    }
  </style>

</head>
<body>

  <div class="container">
    <div class="box"></div>
  </div>

  <div class="container">
    <div class="box1"></div>
  </div>

</body>
</html>
```

![image-20230906203636046](../../../Coderwhy/pic/image-20230906203636046.png)

![image-20230906203626582](../../../Coderwhy/pic/image-20230906203626582.png)

## 2、旋转 - rotate

![image-20230902202346687](../../../Coderwhy/pic/image-20230902202346687.png)

* 旋转：rotate(<angle>)

* 值个数
	* 一个值时，表示旋转的角度

* 值类型：
	* 常用单位deg：旋转的角度（ degrees ）
	* 正数为顺时针
	* 负数为逆时针

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      text-align: center;
      padding-top: 200px;
    }

    .container {
      display: inline-block;
      border: 10px solid #f00;
    }

    .box {
      width: 200px;
      height: 100px;
      background-color: orange;
    }

    .box:hover {
      transform: rotate(-90deg);
    }
  </style>
</head>
<body>

  <div class="container">
    <div class="box"></div>
  </div>

</body>
</html>
```

![image-20230906204617527](../../../Coderwhy/pic/image-20230906204617527.png)![image-20230906204628077](../../../Coderwhy/pic/image-20230906204628077.png)



## 3、rotate补充

![image-20230906204436538](../../../Coderwhy/pic/image-20230906204436538.png)

* 补充一：rotate函数是rotateZ函数的简写写法。
	* rotate3d后续再了解；

* 补充二：rotate的其他单位
	* 事实上rotate支持的单位是很多的；
	* 度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）；



## 4、transform-origin

* transform-origin：形变的原点
	* 比如在进行scale缩放或者rotate旋转时，都会有一个原点。

* 一个值：
	* 设置x轴的原点

* 两个值：
	* 设置x轴和y轴的原点

* 必须是<length>，<percentage>，或 left, center, right, top, bottom关键字中的一个
	* left, center, right, top, bottom关键字
	* length：从左上角开始计算
	* 百分比：参考元素本身大小

![image-20230906205928820](../../../Coderwhy/pic/image-20230906205928820.png)

![image-20230906205936625](../../../Coderwhy/pic/image-20230906205936625.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      text-align: center;
      padding-top: 200px;
    }

    .container {
      display: inline-block;
      border: 10px solid #f00;
    }

    .box {
      width: 200px;
      height: 100px;
      background-color: orange;

      /* 修改当前元素的形变的原点位置 */
      /* transform-origin: left top; */
      /* transform-origin: center top; */
      /* transform-origin: 20px 20px; */
      transform-origin: 20% 20%;
    }

    .box:hover {
      transform: rotate(45deg) scale(0.5, 0.5);
    }
  </style>
</head>
<body>

  <div class="container">
    <div class="box"></div>
  </div>

</body>
</html>
```

![image-20230906210014346](../../../Coderwhy/pic/image-20230906210014346.png)

![image-20230906210024782](../../../Coderwhy/pic/image-20230906210024782.png)

## 5、倾斜 - skew

* 倾斜：skew(x, y)
	* 函数定义了一个元素在二维平面上的倾斜转换。

* 值个数
	* 一个值时，表示x轴上的倾斜
	* 二个值时，表示x轴和y轴上的倾斜

* 值类型：
	* deg：倾斜的角度
	* 正数为顺时针
	* 负数为逆时针

* 注意：倾斜的原点受transform-origin的影响

![image-20230906210109794](../../../Coderwhy/pic/image-20230906210109794.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      text-align: center;
      padding: 200px;
    }

    .box {
      font-style: italic;
      width: 200px;
      height: 100px;
      background-color: orange;
    }

    .box:hover {
      transform: skew(-10deg, 10deg);
    }
  </style>
</head>
<body>
  
  <div class="box">我是div元素</div>

</body>
</html>
```

![image-20230906210947297](../../../Coderwhy/pic/image-20230906210947297.png)

## 6、transform设置多个值

* 前面我们看到了transform的语法，它是可以设置多个transform-function的：
	* 那么就意味着，我们可以给transform设置多个形变的函数；

![image-20230906211039003](../../../Coderwhy/pic/image-20230906211039003.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .box {
      width: 200px;
      height: 100px;
      background-color: orange;
    }

    .box:hover {
      /* transform: translate(50px); */
      /* 后面元素会把前面的覆盖掉 */
      /* transform: scale(1.2);
      transform: rotate(45deg); */

      transform: translate(100px) scale(0.5) rotate(45deg);

      /* 
      <transform-function>+ :一个或者多个，并且多个之间以空格分开 
      transfrom:scale() translate();

      <box-show># : 表示一个或者多个,多个之间以,分割
        box-show : 1px 1px 1px 1px #f00
        */
    }
  </style>
</head>
<body>
  
  <div class="box"></div>

</body>
</html>
```

![image-20230906214829738](../../../Coderwhy/pic/image-20230906214829738.png)



# 四、transition动画

## 1、认识transition动画

* 什么是transition动画呢？
	* CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法。
	* 可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效的；
	* 比如将一个元素从一个位置移动到另外一个位置，默认在修改完CSS属性后会立即生效；
	* 但是我们可以通过CSS transition，让这个过程加上一定的动画效果，包括一定的曲线速率变化；

* 通常将两个状态之间的过渡称为隐式过渡（implicit transitions），因为开始与结束之间的状态由浏览器决定。

* CSS transitions 可以决定
	* 哪些属性发生动画效果 (明确地列出这些属性)
	* 何时开始 (设置 delay）
	* 持续多久 (设置 duration) 
	* 如何动画 (定义timing function，比如匀速地或先快后慢)。



## 2、哪些CSS属性可以做动画呢？

* 并非所有的CSS属性都可以执行动画的，那么我们如何知道哪些属性支持动画呢？

* 方法一：在MDN可执行动画的CSS属性中查询

https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties

* 方法二：阅读CSS属性的文档说明

![image-20230906220926172](../../../Coderwhy/pic/image-20230906220926172.png)

## 3、过渡动画 - transition

* transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简

写属性。

![image-20230907194512979](../../../Coderwhy/pic/image-20230907194512979.png)

* transition-property：指定应用过渡属性的名称
	* all：所有属性都执行动画；
	* none：所有属性都不执行动画；
	* CSS属性名称：要执行动画的CSS属性名称，比如width、left、transform等；
* transition-duration：指定过渡动画所需的时间
	* 单位可以是秒（s）或毫秒（ms）
* transition-timing-function：指定动画的变化曲线
	* https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function
* transition-delay：指定过渡动画执行之前的等待时间

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .container {
      background-color: red;
    }

    .box {
      position: relative;
      left: 0;

      height: 100px;
      width: 200px;
      background-color: orange;

      /* 告知浏览器 box在进行一些CSS属性变化的时候有一个过渡效果 */
      /* transition-property: left; */
      /* transition-property: transform, left; */
      /* transition-property: all;
      transition-duration: 1s;
      transition-timing-function: ease-in;
      transition-delay: 0.2s; */

      /* 简写属性 */
      transition: all 1s ease-in 0.2s;
    }

    .container:hover .box{
      left: 100px;
      transform: translate(100px);
      width: 500px;
    }
  </style>
</head>
<body>
  
  <div class="container">
    <div class="box"></div>
  </div>

</body>
</html>
```

![image-20230907202008802](../../../Coderwhy/pic/image-20230907202008802.png)

![image-20230907202029856](../../../Coderwhy/pic/image-20230907202029856.png)



## 4、几个英语词汇的区分

* transform是形变：
	* 一个CSS属性，该CSS属性用于设置形变；
	* 后面的值是形变的函数，比如scale、rotate、translate；

* translate 是其中一个 transform-function
	* 用于对元素进行平移；

* transition 是过渡的意思
	* 它本身也有转变的含义，但是更多表示的是过渡的过程；



# 五、animation动画

## 1、认识CSS Animation

* 之前我们学习了transition来进行过渡动画，但是过渡动画有如下的缺点：
	* transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态；
	* transition不能重复执行，除非一再触发动画；
	* transition需要在特定状态下会触发才能执行，比如某个属性被修改了；
* 如果我们希望可以有更多状态的变化，我们可以使用**CSS Animation**。
* **CSS Animation的使用分成两个步骤：**
	* 步骤一：使用keyframes定义动画序列（每一帧动画如何执行）
	* 步骤二：配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等等

* 接下来我们一个个步骤来学习。



## 2、@keyframes规则

* 可以使用@keyframes来定义多个变化状态，并且使用animation-name来声明匹配：
	* 关键帧使用percentage来指定动画发生的时间点；
	* 0%表示动画的第一时刻，100%表示动画的最终时刻；
	* 因为这两个时间点十分重要，所以还有特殊的别名：from和to；

* 也就是说可以使用 from 和 to 关键字：
	* from 相当于 0%
	* to 相当于 100%

![image-20230907194943181](../../../Coderwhy/pic/image-20230907194943181.png)



## 3、animation属性

* CSS animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。
* animation-name：指定执行哪一个关键帧动画
* animation-duration：指定动画的持续时间
* animation-timing-function：指定动画的变化曲线
* animation-delay：指定延迟执行的时间
* animation-iteration-count：指定动画执行的次数，执行infinite表示无限动画
* animation-direction：指定方向，常用值normal和reverse
* animation-fill-mode：执行动画最后保留哪一个值
	* none：回到没有执行动画的位置
	* forwards：动画最后一帧的位置
	* backwards：动画第一帧的位置
* animation-play-state：指定动画运行或者暂停（在JavaScript中使用，用于暂停动画）

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .box {
      width: 200px;
      height: 100px;
      background-color: orange;

      /* box 要执行moveAnim的动画 */
      animation-delay: 2s;
      animation-name: moveAnim;
      animation-duration: 3s;
      animation-timing-function: ease-in-out;

      /* 其他属性 */
      animation-iteration-count: 3;
      animation-direction: reverse;

      /* 元素停留在动画的哪个位置，forwards表示停留在最后一个位置 */
      animation-fill-mode: forwards;
      /* js动态修改，点击按钮之后，触发js修改该属性暂停 */
      /* animation-play-state: paused; */

      /* 简写属性 */
    }

    @keyframes moveAnim {
      0% {
        transform: translate(0, 0) scale(0.5, 0.5);
      }

      /* from {
        transform: translate(0, 0) scale(0.5, 0.5);
      } */

      33% {
        transform: translate(0, 200px) scale(1.2, 1.2);
      }

      66% {
        transform: translate(400px, 200px) scale(1, 1);
      }

      100% {
        transform: translate(400px, 0) scale(0.5, 0.5);
      }
      /* to {
        transform: translate(400px, 0) scale(0.5, 0.5);
      } */
    }
  </style>
</head>
<body>
  
  <div class="box"></div>

</body>
</html>
```



# 六、vertical-align

## 1、CSS属性 - vertical-align

![image-20230907195255454](../../../Coderwhy/pic/image-20230907195255454.png)



## 2、深入理解vertical-align – line boxes

* 官方文档的翻译：vertical-align会影响 行内块级元素 在一个 行盒 中垂直方向的位置
* 思考：一个div没有设置高度的时候，会不会有高度？
	* 没有内容，没有高度
	* 有内容，内容撑起来高度

* 但是内容撑起来高度的本质是什么呢？
	* 内容有行高（line-height），撑起来了div的高度

* 行高为什么可以撑起div的高度？
	* 这是因为line boxes的存在，并且line-boxes有一个特性，包裹每行的inline level
	* 而其中的文字是有行高的，必须将整个行高包裹进去，才算包裹这个line-level

* 那么，进一步思考：
	* 如果这个div中有图片，文字，inline-block，甚至他们设置了margin这些属性呢？



## 3、深入理解vertical-align – 不同情况分析

* 情况一：只有文字时，line boxes如何包裹内容？（注意：红色是包裹的div，下面也都一样）

![image-20230907195537764](../../../Coderwhy/pic/image-20230907195537764.png)

* 情况二：有图片，有文字时，line-boxes如何包裹内容？

![image-20230907195549182](../../../Coderwhy/pic/image-20230907195549182.png)

* 情况三：有图片，有文字，有inline-block（比图片要大）如何包裹内容？

![image-20230907195559393](../../../Coderwhy/pic/image-20230907195559393.png)

* 情况四：有图片，有文字，有inline-block（比图片要大）而且设置了margin-bottom，如何包裹内容？

![image-20230907195639855](../../../Coderwhy/pic/image-20230907195639855.png)



* 情况五：有图片、文字、inline-block（比图片要大）而且设置了margin-bottom并且有文字，如何包裹内容？

![image-20230907195651805](../../../Coderwhy/pic/image-20230907195651805.png)





## 4、vertical-align的baseline

* 结论：line-boxes一定会想办法包裹住当前行中所有的内容。

* 但是，但是为什么对齐方式千奇百怪呢？
	* 你认为的千奇百怪，其实有它的内在规律
	* 答案就是baseline对齐

* 我们来看官方vertical-align的默认值：没错，就是baseline

![image-20230907195819819](../../../Coderwhy/pic/image-20230907195819819.png)

* 但是baseline都是谁呢？
	* 文本的baseline是字母x的下方
	* Inline-block默认的baseline是margin-bottom的底部（没有，就是盒子的底部）
	* Inline-block有文本时，baseline是最后一行文本的x的下方

* 一切都解释通了





## 5、vertical-align的其他值

* 现在，对于不同的取值就非常容易理解了
	* baseline(默认值)：基线对齐（你得先明白什么是基线）
	* top：把行内级盒子的顶部跟line boxes顶部对齐
	* middle：行内级盒子的中心点与父盒基线加上x-height一半的线对齐
	* bottom：把行内级盒子的底部跟line box底部对齐
	* <percentage>：把行内级盒子提升或者下降一段距离（距离相对于line-height 计算 \ 元素高度）， 0%意味着同baseline一样
	* <length>：把行内级盒子提升或者下降一段距离，0cm 意味着同 baseline 一样



* 解决图片下边缘的间隙方法:
	* 方法一: 设置成top/middle/bottom
	* 方法二: 将图片设置为block元素

